<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Meditation Timer</title>
    <link rel="manifest" href="/manifest.json" />
    <style>
      :root {
        --button-size: 80vmin;
        --max-button-size: 500px;
        --base-color: #c0c0c0;
        --active-color: #00bcd4;
        --mid-color: #ffeb3b;
        --final-color: #9c27b0;
        --alarm-color: #e53935;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
        padding: 20px;
      }

      /* 洗練されたボタンスタイル */
      .timer-container {
        position: relative;
        width: var(--button-size);
        height: var(--button-size);
        max-width: var(--max-button-size);
        max-height: var(--max-button-size);
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f0f0f0;
        border-radius: 50%;
      }

      /* 外側のリング効果 */
      .outer-ring {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: linear-gradient(
          135deg,
          var(--base-color),
          #e0e0e0,
          var(--base-color)
        );
        opacity: 0.8;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      .timer-button {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        border: none;
        outline: none;
        overflow: hidden;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        transform: scale(1);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2), 0 5px 10px rgba(0, 0, 0, 0.1);
      }

      .timer-button:active {
        transform: scale(0.95);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2), 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      /* 基本的な銀色のグラデーション */
      .gradient-base {
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, #e0e0e0, #c0c0c0, #e0e0e0);
      }

      /* 上部の光沢効果 */
      .highlight {
        position: absolute;
        inset: 0;
        height: 50%;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), transparent);
        opacity: 0.8;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      /* 押し込み効果を強調する内側の影 */
      .inner-shadow {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        background-color: rgba(128, 128, 128, 0.3);
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
      }

      /* アクティブ状態（押し込み時） */
      .timer-button:active .highlight {
        opacity: 0.2;
        height: 16.67%; /* 1/6 */
      }

      .timer-button:active .inner-shadow {
        opacity: 0.3;
      }

      .timer-button:active .depth-gradient {
        opacity: 0.5;
      }

      /* 押し込み時の奥行き感を表現する円形のグラデーション */
      .depth-gradient {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: radial-gradient(circle at center, rgba(0, 0, 0, 0.2) 0%, rgba(0, 0, 0, 0) 70%);
        opacity: 0;
        transition: opacity 0.3s;
      }

      /* フェーズ別のスタイル */
      .timer-container.active-phase1 .outer-ring {
        background: linear-gradient(
          135deg,
          var(--active-color),
          #4dd0e1,
          var(--active-color)
        );
      }

      .timer-container.active-phase1 .gradient-base {
        background: linear-gradient(
          135deg,
          #00bcd4,
          #4dd0e1,
          #00bcd4
        );
      }

      .timer-container.active-phase2 .outer-ring {
        background: linear-gradient(
          135deg,
          var(--mid-color),
          #fff176,
          var(--mid-color)
        );
      }

      .timer-container.active-phase2 .gradient-base {
        background: linear-gradient(
          135deg,
          #ffeb3b,
          #fff176,
          #ffeb3b
        );
      }

      .timer-container.active-phase3 .outer-ring {
        background: linear-gradient(
          135deg,
          var(--final-color),
          #ba68c8,
          var(--final-color)
        );
      }

      .timer-container.active-phase3 .gradient-base {
        background: linear-gradient(
          135deg,
          #9c27b0,
          #ba68c8,
          #9c27b0
        );
      }

      /* アラーム状態 */
      .timer-container.alarm .outer-ring {
        background: linear-gradient(
          135deg,
          var(--alarm-color),
          #ef5350,
          var(--alarm-color)
        );
      }

      .timer-container.alarm .gradient-base {
        background: linear-gradient(
          135deg,
          #e53935,
          #ef5350,
          #e53935
        );
      }

      .timer-container.alarm {
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.98);
        }
        100% {
          transform: scale(1);
        }
      }

      @media (max-width: 600px) {
        :root {
          --button-size: 90vmin;
        }
      }
    </style>
  </head>
  <body>
    <div class="timer-container">
      <div class="outer-ring"></div>
      <button class="timer-button">
        <div class="gradient-base"></div>
        <div class="highlight"></div>
        <div class="inner-shadow"></div>
        <div class="depth-gradient"></div>
      </button>
    </div>

    <script>
      const container = document.querySelector(".timer-container");
      const button = document.querySelector(".timer-button");
      let audio = null; // 初期化しない
      const interval = 5 * 60 * 1000; // 5分間隔
      let phase = 0;
      let timeoutId;
      let wakeLock = null;
      let lastCheckTime = Date.now();
      let storedEndTime = 0;
      let workerCreated = false;
      
      // 定期的なタイマーチェックを行う
      function setupPeriodicChecks() {
        // 1分ごとにタイマー状態をチェック（バックグラウンド対策）
        setInterval(checkTimerStatus, 60000); 
      }

      // Web Workerの初期化
      function initBackgroundWorker() {
        if (!workerCreated && 'serviceWorker' in navigator) {
          // Service Workerの登録
          navigator.serviceWorker.register('sw.js')
            .then(registration => {
              console.log('Service Worker registered with scope:', registration.scope);
              workerCreated = true;
            })
            .catch(error => {
              console.error('Service Worker registration failed:', error);
            });

          // Service Workerからのメッセージを受け取る
          navigator.serviceWorker.addEventListener('message', (event) => {
            if (event.data === 'check-timer') {
              checkTimerStatus();
            }
          });
        }
      }
      
      // タイマーの状態をチェックする関数
      function checkTimerStatus() {
        const storedData = JSON.parse(localStorage.getItem("timerData"));
        const currentTime = Date.now();

        console.log('Timer check at', new Date().toISOString());
        
        if (storedData && storedData.endTime > 0) {
          // タイマー実行中の場合
          if (storedData.endTime <= currentTime) {
            // タイマー終了の場合、アラームを発報
            console.log('Timer check: Timer ended');
            phase = storedData.phase - 1;
            handleTimerEnd();
          } else if (Math.abs((storedData.endTime - currentTime) - (currentTime - lastCheckTime)) > 10000) {
            // 10秒以上の誤差がある場合、タイマーを再調整
            console.log('Timer check: Recalibrating timer');
            clearTimeout(timeoutId);
            phase = storedData.phase - 1;
            timeoutId = setTimeout(handleTimerEnd, storedData.endTime - currentTime);
            container.className = `timer-container active-phase${storedData.phase}`;
            maintainWakeLock();
          }
        }
        
        lastCheckTime = currentTime;
      }

      function triggerAlarm() {
        // 15分経過時(フェーズ2終了時)はアラーム音を鳴らす
        if (phase === 2) {
          // 音声の初期化と再生
          try {
            if (!audio) {
              audio = new Audio("alarm.mp3");
            }
            const playPromise = audio.play();
            
            if (playPromise !== undefined) {
              playPromise.catch(error => {
                console.error("Audio play error:", error);
                // 音声が再生できない場合、代わりにバイブレーション試行
                if (navigator.vibrate) {
                  navigator.vibrate([400, 100, 400, 100, 400]);
                }
              });
            }
          } catch (e) {
            console.error("Audio error:", e);
            // 音声の初期化エラー時もバイブレーションを試行
            if (navigator.vibrate) {
              navigator.vibrate([400, 100, 400, 100, 400]);
            }
          }
        } else {
          // 5分と10分経過時(フェーズ0と1終了時)はバイブレーション
          if (navigator.vibrate) {
            // より強く長いバイブレーションパターン
            navigator.vibrate([300, 100, 300, 100, 300]);
          } else {
            // バイブレーションサポートがない場合は音を鳴らす
            try {
              if (!audio) {
                audio = new Audio("alarm.mp3");
              }
              audio.play().catch(e => console.error("Audio play error:", e));
            } catch (e) {
              console.error("Audio error:", e);
            }
          }
        }
        
        container.classList.add("alarm");
        setTimeout(() => container.classList.remove("alarm"), 2000);
        
        // バックグラウンドでの通知を試みる
        try {
          if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Meditation Timer', {
              body: phase === 2 ? 'メディテーション完了！' : 'フェーズが完了しました',
              icon: 'icon-192.png'
            });
          }
        } catch (e) {
          console.error('Notification error:', e);
        }
      }

      function startTimer() {
        const endTime = Date.now() + interval;
        // タイマー情報をローカルストレージに保存
        localStorage.setItem(
          "timerData",
          JSON.stringify({
            endTime,
            phase: phase + 1,
            startTime: Date.now()
          })
        );

        container.className = `timer-container active-phase${phase + 1}`;
        timeoutId = setTimeout(handleTimerEnd, interval);
        maintainWakeLock();
        
        // タイマー開始時にService Workerを初期化
        initBackgroundWorker();
        
        // バックグラウンド通知の許可を要求
        if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
          Notification.requestPermission();
        }
      }

      function handleTimerEnd() {
        triggerAlarm();
        phase++;

        if (phase < 3) {
          setTimeout(startTimer, 2000);
        } else {
          setTimeout(resetTimer, 2000);
        }
      }

      function resetTimer() {
        container.className = "timer-container";
        localStorage.removeItem("timerData");
        if (wakeLock) {
          try {
            wakeLock.release();
          } catch (e) {
            console.error('WakeLock release error:', e);
          }
        }
        wakeLock = null;
        phase = 0;
        
        // 次のタイマーのための音声の事前ロード
        if (!audio) {
          audio = new Audio("alarm.mp3");
          audio.load();
        }
      }

      async function maintainWakeLock() {
        // 画面をオンにし続ける
        try {
          if ('wakeLock' in navigator && !wakeLock) {
            wakeLock = await navigator.wakeLock.request("screen");
            wakeLock.addEventListener("release", () => {
              console.log('WakeLock released');
              wakeLock = null;
              // WakeLockが解放されたら再取得を試みる
              setTimeout(maintainWakeLock, 1000);
            });
            console.log('WakeLock acquired');
          }
        } catch (err) {
          console.error("Wake Lock Error:", err);
        }
      }

      // イベントリスナー
      button.addEventListener("click", () => {
        // 音声ファイルの初期化
        if (!audio) {
          audio = new Audio("alarm.mp3");
          // 音量を事前に設定しておく
          audio.volume = 1.0;
          // ユーザー操作後に音をロードする
          audio.load();
        }
        
        // バイブレーションのテスト
        if (navigator.vibrate && phase === 0) {
          navigator.vibrate(1); // 短い振動でバイブレーション権限を確認
        }
        
        if (phase === 0) startTimer();
      });

      // 長押しリセット機能の追加
      let pressTimer;

      // マウスダウン/タッチスタート時の長押し検出
      button.addEventListener("mousedown", startLongPressTimer);
      button.addEventListener("touchstart", startLongPressTimer, { passive: true });

      // マウスアップ/タッチエンド時の処理
      button.addEventListener("mouseup", cancelLongPressTimer);
      button.addEventListener("touchend", cancelLongPressTimer);

      // 要素から離れた場合もタイマーをキャンセル
      button.addEventListener("mouseleave", cancelLongPressTimer);
      button.addEventListener("touchcancel", cancelLongPressTimer);

      function startLongPressTimer(e) {
        pressTimer = setTimeout(() => {
          // 長押し時の視覚的フィードバック
          container.classList.add("alarm");
          setTimeout(() => {
            resetTimer();
            container.classList.remove("alarm");
          }, 500);
        }, 2000); // 2秒の長押しでリセット
      }

      function cancelLongPressTimer(e) {
        clearTimeout(pressTimer);
      }

      // アプリケーション起動時の処理
      window.addEventListener("load", () => {
        // 以前のタイマー状態を復元
        const storedData = JSON.parse(localStorage.getItem("timerData"));
        if (storedData && storedData.endTime > Date.now()) {
          phase = storedData.phase - 1;
          const remaining = storedData.endTime - Date.now();
          timeoutId = setTimeout(handleTimerEnd, remaining);
          container.className = `timer-container active-phase${storedData.phase}`;
          maintainWakeLock();
        }
        
        // バックグラウンド対策の初期化
        initBackgroundWorker();
        setupPeriodicChecks();
      });

      // 画面の表示/非表示状態の変更時
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          // 画面が表示状態に戻った時、タイマーを正確な時間で更新
          const storedData = JSON.parse(localStorage.getItem("timerData"));
          if (storedData && storedData.endTime > Date.now()) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(
              handleTimerEnd,
              storedData.endTime - Date.now()
            );
            maintainWakeLock(); // WakeLockを再取得
          }
        } else {
          // 画面が非表示になった時、現在時刻を記録
          lastCheckTime = Date.now();
        }
      });
      
      // ページ終了時にタイマー状態を保存
      window.addEventListener("beforeunload", () => {
        const storedData = JSON.parse(localStorage.getItem("timerData"));
        if (storedData && storedData.endTime > Date.now()) {
          console.log('Saving timer state before unload');
          // タイマー状態を更新して保存
          localStorage.setItem(
            "timerData",
            JSON.stringify({
              ...storedData,
              lastCheck: Date.now()
            })
          );
        }
      });
    </script>
  </body>
</html>
