<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Meditation Timer (改良版)</title>
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#43a047" />
    <style>
      :root {
        --button-size: 80vmin;
        --max-button-size: 500px;
        --base-color: #c0c0c0;
        --active-color: #4caf50;
        --mid-color: #8bc34a;
        --final-color: #009688;
        --alarm-color: #e53935;
        --progress-color: rgba(255, 255, 255, 0.2);
        --background-color: #f5f5f5;
        --shadow-color: rgba(0, 0, 0, 0.2);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --base-color: #424242;
          --background-color: #121212;
          --shadow-color: rgba(0, 0, 0, 0.5);
        }
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: var(--background-color);
        padding: 20px;
        transition: background-color 0.5s ease;
      }

      .timer-container {
        position: relative;
        width: var(--button-size);
        height: var(--button-size);
        max-width: var(--max-button-size);
        max-height: var(--max-button-size);
      }

      .progress-ring {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        transform: rotate(-90deg);
      }

      .progress-ring circle {
        width: 100%;
        height: 100%;
        fill: transparent;
        stroke-width: 3px;
        stroke: var(--progress-color);
        stroke-linecap: round;
        transform-origin: center;
      }

      .timer-button {
        position: relative;
        z-index: 1;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: none;
        background: linear-gradient(
          135deg,
          var(--base-color),
          #e0e0e0,
          var(--base-color)
        );
        box-shadow: 0 0 20px var(--shadow-color),
          inset 0 0 10px rgba(255, 255, 255, 0.5), 0 10px 0 #d4d4d4;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        outline: none; /* アクセシビリティには注意 */
      }

      .timer-button:active {
        transform: translateY(5px);
        box-shadow: 0 0 10px var(--shadow-color),
          inset 0 0 10px rgba(255, 255, 255, 0.5), 0 5px 0 #d4d4d4;
      }

      .timer-button.active-phase1 {
        background: linear-gradient(
          135deg,
          var(--active-color),
          #66bb6a,
          var(--active-color)
        );
        box-shadow: 0 0 20px var(--shadow-color),
          inset 0 0 10px rgba(255, 255, 255, 0.5), 0 5px 0 #2e7d32;
        animation: breathe 10s infinite ease-in-out;
      }

      .timer-button.active-phase2 {
        background: linear-gradient(
          135deg,
          var(--mid-color),
          #9ccc65,
          var(--mid-color)
        );
        box-shadow: 0 0 20px var(--shadow-color),
          inset 0 0 10px rgba(255, 255, 255, 0.5), 0 5px 0 #558b2f;
        animation: breathe 10s infinite ease-in-out;
      }

      .timer-button.active-phase3 {
        background: linear-gradient(
          135deg,
          var(--final-color),
          #4db6ac,
          var(--final-color)
        );
        box-shadow: 0 0 20px var(--shadow-color),
          inset 0 0 10px rgba(255, 255, 255, 0.5), 0 5px 0 #00695c;
        animation: breathe 10s infinite ease-in-out;
      }

      .timer-button.alarm {
        background: linear-gradient(
          135deg,
          var(--alarm-color),
          #ef5350,
          var(--alarm-color)
        );
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3),
          inset 0 0 10px rgba(255, 255, 255, 0.3), 0 5px 0 #c62828;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.95);
          box-shadow: 0 0 25px rgba(229, 57, 53, 0.5),
            inset 0 0 15px rgba(255, 255, 255, 0.3), 0 5px 0 #c62828;
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes breathe {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.99);
        }
      }

      @media (max-width: 600px) {
        :root {
          --button-size: 90vmin;
        }
      }

      /* スクリーンリーダー対応 */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }
    </style>
  </head>
  <body>
    <div class="timer-container">
      <svg class="progress-ring" viewBox="0 0 100 100">
        <circle
          id="progress-circle"
          cx="50"
          cy="50"
          r="45"
          stroke-dasharray="283"
          stroke-dashoffset="283"
        />
      </svg>
      <button class="timer-button" aria-label="15分のメディテーションタイマーを開始">
        <span class="sr-only" id="timer-status">停止中</span>
      </button>
    </div>

    <script>
      // 定数
      const DEFAULT_INTERVAL = 5 * 60 * 1000; // 5分間隔（合計15分）
      const PHASES = 3;
      
      // DOM要素
      const button = document.querySelector(".timer-button");
      const statusText = document.getElementById("timer-status");
      const progressCircle = document.getElementById("progress-circle");
      const circumference = 2 * Math.PI * 45; // SVG円の円周
      
      // 状態変数
      let phase = 0;
      let interval = DEFAULT_INTERVAL;
      let timeoutId;
      let wakeLock = null;
      let startTime;
      let animationFrameId;
      
      // オーディオ設定
      const audio = new Audio("alarm.mp3");
      audio.preload = "auto";
      
      // プログレス更新関数
      function updateProgress() {
        if (!startTime || phase === 0) return;
        
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / interval, 1);
        const dashOffset = circumference * (1 - progress);
        
        progressCircle.style.strokeDashoffset = dashOffset;
        progressCircle.style.stroke = getComputedStyle(document.documentElement)
          .getPropertyValue(`--active-color`).trim();
        
        if (progress < 1) {
          animationFrameId = requestAnimationFrame(updateProgress);
        }
      }
      
      // アラーム関数
      function triggerAlarm() {
        audio.play();
        button.classList.add("alarm");
        statusText.textContent = "アラーム中";
        
        // バイブレーション（サポートされている場合）
        if (navigator.vibrate) {
          navigator.vibrate([300, 100, 300]);
        }
        
        setTimeout(() => button.classList.remove("alarm"), 2000);
      }
      
      // タイマー開始関数
      function startTimer() {
        startTime = Date.now();
        const endTime = startTime + interval;
        
        // 状態保存
        localStorage.setItem(
          "timerData",
          JSON.stringify({
            endTime,
            phase: phase + 1,
            interval
          })
        );
        
        // UI更新
        button.className = `timer-button active-phase${phase + 1}`;
        statusText.textContent = `フェーズ ${phase + 1} 実行中`;
        progressCircle.style.strokeDasharray = circumference;
        progressCircle.style.strokeDashoffset = circumference;
        
        // タイマー設定とプログレス更新開始
        timeoutId = setTimeout(handleTimerEnd, interval);
        updateProgress();
        maintainWakeLock();
      }
      
      // タイマー終了処理
      function handleTimerEnd() {
        cancelAnimationFrame(animationFrameId);
        triggerAlarm();
        phase++;
        
        if (phase < PHASES) {
          setTimeout(startTimer, 2000);
        } else {
          setTimeout(resetTimer, 2000);
        }
      }
      
      // タイマーリセット関数
      function resetTimer() {
        cancelAnimationFrame(animationFrameId);
        button.className = "timer-button";
        progressCircle.style.strokeDashoffset = circumference;
        progressCircle.style.stroke = "rgba(255, 255, 255, 0.2)";
        localStorage.removeItem("timerData");
        statusText.textContent = "停止中";
        
        if (wakeLock) {
          wakeLock.release().catch(err => console.error("Wake Lock解放エラー:", err));
          wakeLock = null;
        }
        
        phase = 0;
      }
      
      // Wake Lock維持関数
      async function maintainWakeLock() {
        if ("wakeLock" in navigator) {
          try {
            if (!wakeLock) {
              wakeLock = await navigator.wakeLock.request("screen");
              wakeLock.addEventListener("release", () => {
                console.log("Wake Lock解放");
                wakeLock = null;
              });
            }
          } catch (err) {
            console.error("Wake Lockエラー:", err);
          }
        }
      }
      
      // カスタム時間設定（長押し検出）
      let longPressTimer;
      let customTimeMode = false;
      
      function startLongPressDetection() {
        if (phase !== 0) return; // タイマー実行中は無効
        
        longPressTimer = setTimeout(() => {
          customTimeMode = true;
          interval = DEFAULT_INTERVAL; // リセット
          button.style.borderColor = "#ffeb3b";
          button.style.borderWidth = "3px";
          button.style.borderStyle = "solid";
        }, 2000);
      }
      
      function stopLongPressDetection() {
        clearTimeout(longPressTimer);
        
        if (customTimeMode) {
          customTimeMode = false;
          button.style.border = "none";
        }
      }
      
      // カスタム時間設定（タップでの時間増加）
      function incrementTime() {
        if (!customTimeMode) return;
        
        // 1分ずつ増加（最大30分）
        interval += 60 * 1000;
        if (interval > 30 * 60 * 1000) {
          interval = 5 * 60 * 1000;
        }
        
        // フィードバック
        const minutes = interval / (60 * 1000);
        button.classList.add("active-phase1");
        statusText.textContent = `${minutes}分に設定`;
        
        setTimeout(() => {
          button.classList.remove("active-phase1");
        }, 200);
        
        // バイブレーション
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      }
      
      // イベントリスナー
      button.addEventListener("click", () => {
        if (customTimeMode) {
          incrementTime();
        } else if (phase === 0) {
          startTimer();
        } else {
          // アラーム中の場合は停止
          if (button.classList.contains("alarm")) {
            audio.pause();
            audio.currentTime = 0;
            button.classList.remove("alarm");
          }
        }
      });
      
      // 長押し検出
      button.addEventListener("touchstart", startLongPressDetection);
      button.addEventListener("mousedown", startLongPressDetection);
      
      button.addEventListener("touchend", stopLongPressDetection);
      button.addEventListener("mouseup", stopLongPressDetection);
      button.addEventListener("mouseleave", stopLongPressDetection);
      
      // キーボードアクセシビリティ
      button.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          button.click();
        }
      });
      
      // 状態復元
      window.addEventListener("load", () => {
        const storedData = JSON.parse(localStorage.getItem("timerData"));
        if (storedData && storedData.endTime > Date.now()) {
          phase = storedData.phase - 1;
          interval = storedData.interval || DEFAULT_INTERVAL;
          startTime = storedData.endTime - interval;
          const remaining = storedData.endTime - Date.now();
          
          timeoutId = setTimeout(handleTimerEnd, remaining);
          button.className = `timer-button active-phase${storedData.phase}`;
          statusText.textContent = `フェーズ ${storedData.phase} 実行中`;
          
          // プログレス復元
          const elapsed = interval - remaining;
          const progress = elapsed / interval;
          progressCircle.style.strokeDasharray = circumference;
          progressCircle.style.strokeDashoffset = circumference * (1 - progress);
          progressCircle.style.stroke = getComputedStyle(document.documentElement)
            .getPropertyValue(`--active-color`).trim();
          
          updateProgress();
          maintainWakeLock();
        }
      });
      
      // 表示状態変更時の処理
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          const storedData = JSON.parse(localStorage.getItem("timerData"));
          if (storedData && storedData.endTime > Date.now()) {
            clearTimeout(timeoutId);
            
            // 残り時間再計算
            const remaining = storedData.endTime - Date.now();
            timeoutId = setTimeout(handleTimerEnd, remaining);
            
            // アニメーションフレームの再開
            cancelAnimationFrame(animationFrameId);
            startTime = storedData.endTime - (storedData.interval || DEFAULT_INTERVAL);
            updateProgress();
          }
        }
      });
      
      // Service Worker登録
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("/sw.js").then(
            (reg) => console.log("SW登録成功:", reg.scope),
            (err) => console.error("SW登録失敗:", err)
          );
        });
      }
    </script>
  </body>
</html>